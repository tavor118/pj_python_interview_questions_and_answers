## Files and I/O (Введення-Виведення)

### Що таке файловий об'єкт

Файловий об'єкт - це об'єкт, який надає файлово-орієнтований API (методи `read()`, `write()` та ін.) для доступу до ресурсу. Залежно від способу створення, файловий об'єкт може надавати доступ до реального файлу на диску або іншого типу пристрою зберігання або передачі даних (стандартні потоки введення/виведення, буфери у пам'яті, сокети і т.д.). Файлові об'єкти також називають потоками. Файлові об'єкти є контекстними менеджерами.


### Які існують типи файлових об'єктів

У Python існують три типи файлових об'єктів
- Текстові файли (text files): Ці файли використовуються для роботи з текстовими даними. Вони працюють з рядками (строками) і автоматично виконують кодування і декодування символів, а також перетворення символів кінця рядка (\n, \r, \r\n) між стандартними відображенням в пам'яті та збереженням на диску. Для роботи з текстовими файлами використовуються класи `TextIOWrapper` і `TextIO` з модуля `io`.
- Буферизовані бінарні файли (buffered binary files): Ці файли використовуються для роботи з бінарними даними. Вони працюють з байтами і зберігають дані без будь-яких змін або перетворень. Буферизовані бінарні файли мають більш ефективну систему буферизації для швидкого зчитування та запису даних. Для роботи з буферизованими бінарними файлами використовується клас `BufferedReader` з модуля `io`.
- Небуферизовані бінарні файли (raw binary files): Ці файли також використовуються для роботи з бінарними даними. Вони працюють з байтами і не мають системи буферизації. Це означає, що дані безпосередньо записуються або зчитуються з диску при кожній операції. Для роботи з небуферизованими бінарними файлами використовується клас `BufferedWriter` з модуля `io`.


### В чому відмінність текстових і бінарних файлів

Текстові файли записують і зчитують дані типу `str` і автоматично виконують перетворення кодувань і символів кінця рядка. Бінарні файли записують і зчитують дані типів `bytes` і `bytearray` і не виконують жодних маніпуляцій з даними: все записується і зчитується в тому ж самому вигляді, як зберігається.


### Як користуватися функцією `open`

Сигнатура функції

```python
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
```

Основні параметри:
- `file` - ім'я файлу або файловий дескриптор
- `mode` - режим відкриття файлу
- `encoding` - кодування файлу
- `buffering` - використовувати буферизацію: від'ємне число (за замовчуванням, явно вказувати не потрібно) - стандартне значення для даного типу файлового об'єкту, 0 - вимкнути буферизацію, 1 - построчна буферизація (для текстових файлів), інше значення - увімкнути буферизацію і встановити відповідний розмір буфера

Обов'язковим параметром є лише перший. Найчастіше функцію `open()` використовують з двома параметрами.

`mode` може починатися з символів `"r"` (читання), `"w"` (запис, очищує файл, якщо він вже існує), `"x"` (виключне створення, неуспішно, якщо файл вже існує), 
`"a"` (додавання, запис в кінець файлу). Також параметр `mode` може мати другу літеру для визначення типу файлу: `"t"` для текстового (за замовчуванням) і `"b"` для бінарного. Також можна додати символ `"+"` для відкриття в режимі читання і запису одночасно. Порядок останніх двох символів не має значення: `"rb+"` і `"r+b"` задають один і той же режим.


### З чого складається процес закриття файлів

Після завершення роботи з файлом важливо обов'язково його закрити за допомогою методу `close()`, особливо якщо файл був відкритий для запису. При використанні буферизованого виводу дані, які записуються в файл, спочатку зберігаються в буфері. Вміст буфера записується в файл при його заповненні або при виклику методів `flush()` або `close()`. 

Крім того, якщо файл відкритий для запису, він буде заблокований для інших процесів на запис до моменту його закриття. Усі відкриті файли автоматично закриваються при видаленні відповідних файлових об'єктів з пам'яті збирачем сміття інтерпретатора Python або при завершенні роботи самого інтерпретатора, проте слід тримати файли відкритими мінімально необхідний час.


### Що роблять методи `tell` і `seek`

Метод `tell()` повертає поточну позицію зчитування/запису в файлі. Метод `seek(offset, whence)` встановлює її. Параметр `offset` визначає зсув, 
а `whence` - точку, від якої цей зсув обчислюється: `io.SEEK_SET(0)` - початок файлу, `io.SEEK_CUR(1)` - поточна позиція, `io.SEEK_END(2)` - кінець файлу.


### Що роблять `StringIO` і `BytesIO`

Класи `io.StringIO` і `io.BytesIO` представляють потоки для зчитування та запису в рядки або байтові рядки у пам'яті. Вони можуть використовуватися для використання рядків і байтових рядків як текстових і бінарних файлів. Надають інтерфейс файлу без взаємодії з файловою системою.


### Чи є файлові об'єкти контекстними менеджерами

Так, вони є.


### Що таке серіалізація

**Серіалізація** - це процес збереження об'єктів у бінарному або рядковому вигляді для зберігання, передачі та відновлення. Зворотний процес називається десеріалізацією. 


### json.dumps / json.dump, json.loads / json.load

Функція `dumps` модуля `json` зберігає представлення об'єкта у форматі JSON у рядок. 
Функція `dump` - у текстовий файл.
Функція `loads` модуля `json` завантажує об'єкт з рядка. 
Функція `load` - з текстового файлу.


### Що робити, якщо потрібно серіалізувати дані, які не підтримуються стандартним модулем json

Можна використовувати `pickle` або розширити класи `JSONEncoder` і `JSONDecoder`.


### pickle.dumps / pickle.dump, pickle.loads / pickle.load

Функції `dump`, `dumps`, `load` і `loads` модуля `pickle` аналогічні за своїм призначенням відповідним функціям модуля `json`, але працюють з байтовими рядками 
та бінарними файлами.

