## Python Packages

### Що таке PyPi та pip

**PyPi (Python Package Index)** - це онлайн-репозиторій, де розміщені різні пакети та бібліотеки для мови програмування Python. Ці пакети містять готовий код та ресурси, які можуть бути використані розробниками для вирішення різних завдань.

`pip` (Pip Installs Packages) - це інструмент командного рядка, який використовується для встановлення та керування пакетами з PyPi. За допомогою `pip` розробники можуть швидко та легко встановлювати пакети, необхідні для своїх проектів, і також оновлювати або видаляти їх.

Отже, PyPi - це репозиторій пакетів для Python, а `pip` - інструмент для їх встановлення та керування.


### Які є популярні менеджери пакетів ?

Менеджери пакетів у Python дозволяють легко встановлювати, оновлювати та керувати бібліотеками і залежностями. 

Найпопулярніші

- **pip**  - стандартний менеджер пакетів у Python, який постачається разом із сучасними версіями Python. Використовується для встановлення бібліотек із репозиторію PyPI (Python Package Index). Підтримує базову роботу із залежностями та має широкий набір команд, таких як `install`, `uninstall`, `freeze`.

```bash
pip install requests  # Install the requests library
pip freeze > requirements.txt  # Export dependencies to a file
```

- **poetry**  - сучасний інструмент для управління залежностями і пакетування проєктів. Включає можливості керування середовищем і генерації файлу `pyproject.toml`, який стає стандартом для Python-проєктів.

```bash
poetry add flask  # Add Flask to the project
poetry install  # Install all dependencies from pyproject.toml
```

- **pipenv**  - менеджер для роботи із залежностями та віртуальними середовищами, який інтегрує функції `pip` і `virtualenv`. Генерує файли `Pipfile` і `Pipfile.lock` для точного відтворення середовища.

```bash
pipenv install django  # Install Django and manage virtual environment
pipenv shell  # Activate the virtual environment
```

- **conda**  - менеджер пакетів і середовищ, популярний серед науковців та користувачів Anaconda. Підтримує як Python-пакети, так і системні залежності. Добре підходить для управління середовищами з важкими залежностями.

```bash
conda install numpy  # Install numpy using conda
conda create -n myenv python=3.9  # Create a new environment
```


### Які є популярні Python бібліотеки?

- **NumPy** - бібліотека для обчислень з масивами даних, що надає зручні інструменти для роботи з масивами та матрицями, включаючи багато математичних функцій та операцій над масивами.
- **Pandas** - бібліотека для аналізу та обробки даних, що надає високопродуктивні та зручні інструменти для роботи з табличними даними, включаючи функціональність для читання, запису, фільтрації, агрегації, об'єднання та маніпуляції даними.
- **Matplotlib** -  бібліотека для візуалізації даних у Python, що дозволяє створювати графіки, діаграми, діаграми розсіювання та інші типи візуалізації даних.
- **Requests** - бібліотека для роботи з HTTP-запитами у Python, що дозволяє виконувати GET, POST та інші типи запитів, управляти сеансами, передавати параметри, обробляти cookies.
- **HTTPX**, **aiohttp** - аналоги requests для асинхронних запитів.
- **Beautiful Soup** - бібліотека для витягування даних з HTML та XML файлів.
- **SQLAlchemy** - бібліотека для роботи з базами даних, що надає ORM (Object Relational Mapping) та інші інструменти для зручної роботи з різними базами даних, такими як SQLite, MySQL, PostgreSQL та іншими.
- **TensorFlow** і **PyTorch** - бібліотеки машинного навчання та глибокого навчання, що надають інструменти для створення та навчання нейронних мереж, реалізацію різних архітектур моделей та виконання складних завдань машинного навчання.


### Що таке веб-фреймворк? Популярні python фреймворки

**Веб-фреймворк** - це програмний каркас або набір бібліотек та інструментів, які допомагають розробникам створювати веб-додатки та веб-сайти. Вони надають структуру та організовану методологію для розробки веб-додатків, що дозволяє розробникам ефективно працювати над різноманітними аспектами веб-розробки, такими як маршрутизація, обробка запитів, робота з базами даних, безпека і багато інших.

Основні фреймворки

- **Django** - це повнофункціональний та високорівневий веб-фреймворк, який надає інструменти для швидкої та зручної розробки веб-додатків. Він включає в себе всі необхідні компоненти, такі як система аутентифікації, ORM (Object-Relational Mapping), система адміністрування і багато інших.
- **Flask** - це мінімалістичний веб-фреймворк, який надає базовий набір інструментів для створення веб-додатків. Він дуже легкий і гнучкий, що дає розробникам більший контроль над тим, як організовувати свій код.
- **FastAPI** - це сучасний фреймворк для створення веб-додатків API, який відзначається швидкістю розробки та автоматичною генерацією документації за допомогою Swagger.

Існують ще наступні фреймворки

- **Tornado** - це асинхронний веб-фреймворк, призначений для створення високоефективних веб-додатків, особливо тих, які вимагають багато взаємодій на основі подій.
- **CherryPy** - це легкий і простий веб-фреймворк, який надає основні засоби для створення веб-додатків.
- **Pyramid** - це фреймворк, який надає багато гнучкості та дозволяє розробникам обирати компоненти, які вони хочуть використовувати, щоб побудувати свій додаток.
- **Web2py** - це фреймворк зі вбудованим середовищем розробки, який полегшує розробку та розгортання веб-додатків.



### pytest

**pytest** - це популярна Python бібліотека для тестування коду.

Основні переваги `pytest`

- Дозволяє створювати тести у вигляді звичайних функцій, які починаються з `test_`, без необхідності використання класів.
- Забезпечує зручний механізм для асертів: `assert` працює інтуїтивно і надає зрозумілий звіт у разі помилок.
- Підтримує автоматичне виявлення тестових файлів і функцій, що спрощує організацію тестів.
- Надає фікстури (`fixtures`) для налаштування та повторного використання коду, що виконується до або після тестів.
- Підтримує розширення функціоналу через вбудовані або сторонні плагіни, наприклад, для тестування API, продуктивності, інтеграції з CI/CD.
- Пропонує докладні та зрозумілі звіти про результати виконання тестів, зручні для аналізу.

Фікстури у pytest - це спеціальні функції або методи, які допомагають підготувати середовище для виконання тестів. Вони дозволяють створювати початкові умови для тестів та об'єкти, які тести будуть використовувати. Фікстури можуть викликати одна одну, бути динамічними. Можна налаштувати scope - як довго буде існувати фікстура під час виконання тестів. Це дозволяє керувати тим, коли фікстура буде створюватися та знищуватися - перед кожною функцією-тестом (function), один раз для кожного класу тестів (class) чи один раз на весь період виконання pytest-сесії, тобто під час виконання всіх тестів (session).

```python
import pytest

def add(a, b):  # Function to be tested
    return a + b

def test_add():  # Test function
    assert add(2, 3) == 5  # Assert the result
    assert add(-1, 1) == 0
    assert add(0, 0) == 0

@pytest.fixture  # Using a fixture for setup and teardown
def sample_data():
    return {"key": "value"}

def test_with_fixture(sample_data):
    assert sample_data["key"] == "value"
```

*Links*

- https://habr.com/ru/articles/269759/


### Які ви знаєте інструменти для перевірки кодового стилю?

**Flake8** - обгортка для python утиліт - pyflakes, pycodestyle, mccabe. Flake8 має схожий на pylint основний функціонал. Проте він має кілька відмінностей та особливостей

- Можливості статистичних звітів обмежені підрахунком кількості кожної з помилок (—statistics) та їх загальною кількістю (—count).
- Для запуску у кілька потоків (`—jobs=<num>`) використовується модуль multiprocessing, через що багатопоточність не працюватиме на системах Windows.
- Відсутня можливість генерації звітів у форматі json, при виклику з ключем —bug-report створюється лише заголовок для звіту з вказанням платформи та версій вхідних утиліт.
- Коментарі у коді, які блокують вивід. Додавання коментаря `# noqa` у рядку з помилкою вилучить його зі звіту.
- Під час редагування можна вказати виключені помилки "на льоту" у ключі `—extend-ignore=<errors>`
- Перевірка синтаксису у рядках doctest (-doctests).
- Наявність Version Control Hooks. Інтеграція з системами контролю версій відбувається буквально за допомогою двох команд (підтримуються git та mercurial).
- Розширюваність. Flake8 для аналізу коду Python дозволяє створювати та використовувати плагіни. За допомогою плагінів у Flake8 можна: додавати додаткові перевірки, використовувати інші формати звітів або автоматично виправляти знайдені помилки. На PyPi можна знайти велику кількість відкритих плагінів.

**black** - популярний інструмент для форматування коду. Підтримує гнучке налаштування. 

**Pylint** поєднує в собі як пошук логічних, так і стилістичних помилок. Цей потужний інструмент для аналізу коду Python відрізняється великою кількістю перевірок і різноманітністю звітів.

**autopep8** модифікує код, який не відповідає PEP8. Перевірка відповідності конвенціям здійснюється за допомогою утиліти pycodestyle. У autopep8 є підтримка багатопоточності, рекурсивного обходу каталогів, можливість збереження налаштувань у файлі, вказання діапазону рядків для виправлення, фільтрація помилок та безпосереднє форматування файлу.

**Vulture** - невеликий утилітарний інструмент для пошуку "мертвого" коду в програмах Python. Він використовує модуль ast стандартної бібліотеки і створює абстрактні синтаксичні дерева для всіх файлів початкового коду в проекті. Далі він шукає всі об'єкти, які були визначені, але не використовуються. Vulture корисно використовувати для очищення та виявлення помилок у великих базових кодах.

*Links*

- [Инструменты для анализа кода Python. Часть 1](https://proglib.io/p/python-code-analysis/)
- [Инструменты для анализа кода Python. Часть 2](https://proglib.io/p/python-code-analysis-tools/)


### SQLAlchemy (Core та ORM частин)

**SQLAlchemy** — це популярна бібліотека Python для роботи з базами даних, яка надає два основних рівні абстракції: Core (рівень низького рівня) та ORM (рівень об'єктно-реляційного мапінгу).

**SQLAlchemy Core** - це низькорівнева частина бібліотеки, яка дозволяє працювати з SQL-запитами безпосередньо, використовуючи Python-об’єкти.

- Забезпечує об'єктно-орієнтоване представлення таблиць, стовпців і типів даних через `Table`, `Column` і `MetaData`.
- Надає інструменти для створення SQL-запитів за допомогою конструктора запитів (`select`, `insert`, `update`, `delete`).
- Дозволяє виконувати SQL-запити через об'єкти з'єднань (`Connection`) та управління транзакціями.

```python
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, select

engine = create_engine("sqlite:///example.db")  # Create an engine and metadata
metadata = MetaData()

users = Table(  # Define a table
    "users",
    metadata,
    Column("id", Integer, primary_key=True),
    Column("name", String),
    Column("age", Integer),
)

metadata.create_all(engine)  # Create the table


with engine.connect() as connection:  # Insert data
    connection.execute(users.insert(), [{"name": "Alice", "age": 25}, {"name": "Bob", "age": 30}])


with engine.connect() as connection:  # Query data
    result = connection.execute(select(users.c.name, users.c.age))
    for row in result:
        print(row)
```

**SQLAlchemy ORM** - це високорівнева частина, яка дозволяє працювати з базою даних через Python-об'єкти, створюючи маппінг між таблицями та класами.

- Замість роботи з рядками таблиць, розробник оперує об'єктами, які відповідають записам у таблицях.
- Включає декларативний стиль для оголошення моделей за допомогою класів, які успадковуються від `Base`.
- Підтримує сесії (`Session`) для управління об'єктами, транзакціями та зв'язком із базою даних.

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()  # Define the base and engine
engine = create_engine("sqlite:///example.db")

class User(Base):  # Define a model
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    name = Column(String)
    age = Column(Integer)

Base.metadata.create_all(engine)  # Create the table

Session = sessionmaker(bind=engine)  # Create a session
session = Session()

session.add(User(name="Alice", age=25))  # Add and query data
session.add(User(name="Bob", age=30))
session.commit()

for user in session.query(User).all():  # Query using ORM
    print(user.name, user.age)
```

- Core підходить для низькорівневого доступу до бази даних, дозволяючи виконувати складні SQL-запити, не створюючи об’єктів Python.
- ORM полегшує роботу, якщо потрібна тісна інтеграція об'єктів Python із базою даних, і зменшує кількість коду для роботи з даними.


### Celery

**Celery** — це зручний інструмент для асинхронного виконання завдань у Python. Він дозволяє виконувати довготривалі або ресурсозатратні операції у фоновому режимі, що підвищує продуктивність та швидкодію веб-застосунків. 

Основні аспекти Celery

- Це система управління чергами завдань, яка використовує брокери повідомлень (наприклад, RabbitMQ, Redis) для обробки черг.
- Підтримує асинхронні, відкладені або періодичні завдання через інтеграцію з планувальниками, такими як Celery Beat.
- Забезпечує високу масштабованість завдяки можливості запуску кількох воркерів, які паралельно обробляють завдання.
- Підтримує відстеження статусу завдань та отримання результатів через систему бекендів, таких як Redis, SQL, чи AMQP.
- Інтегрується з популярними веб-фреймворками, такими як Django чи Flask, що дозволяє легко налаштувати асинхронну обробку в проєктах.
- Забезпечує автоматичну повторну спробу завдань у разі помилок.

Celery підтримує

- Асинхронні завдання: Завдання виконуються у фоновому режимі без блокування основного процесу.
- Періодичні завдання: Використання Celery Beat дозволяє запускати завдання за розкладом.
- Моніторинг: Підтримує інтеграцію з такими інструментами, як Flower, для моніторингу черг і стану завдань.

- Налаштування Celery у проєкті

```python
from celery import Celery


app = Celery("tasks", broker="redis://localhost:6379/0", backend="redis://localhost:6379/0")  # Initialize Celery


@app.task  
def add(x, y):  # Define a task
    return x + y
```

- Запуск завдання

```python
from tasks import add

result = add.delay(4, 6)  # Call the task asynchronously

print("Task Status:", result.status)  # Check the status or get the result
print("Task Result:", result.get(timeout=10))
```

- Запуск воркера

```bash
celery -A tasks worker --loglevel=info
```

- Періодичні завдання з Celery Beat:

```python
from celery import Celery
from celery.schedules import crontab

app = Celery("tasks", broker="redis://localhost:6379/0")

@app.on_after_configure.connect
def setup_periodic_tasks(sender, **kwargs):  # Define periodic tasks
    
    sender.add_periodic_task(60.0, sample_task.s("Hello"), name="Print every minute")  # Execute every minute
    
@app.task
def sample_task(message):
    print(message)
```

Celery надає набір примітивів для створення складних робочих процесів і управління асинхронними завданнями. Ці примітиви дозволяють будувати ланцюжки, групи завдань і виконувати їх паралельно чи послідовно. 

Основні примітиви Celery

- **Task**  - основний будівельний блок у Celery. Завдання (`task`) — це окрема функція, яка може виконуватись асинхронно. Завдання можна запускати незалежно, передавати аргументи, отримувати статус і результат.
    
```python
@app.task
def add(x, y):
	return x + y

result = add.delay(4, 5)  # Asynchronous call
print(result.get())  # Get result
```
    
- **Chain**  - використовується для послідовного виконання завдань, де результат одного завдання передається як вхідний аргумент наступному.
    
```python
from celery import chain

@app.task
def multiply(x, y):
	return x * y

chain_result = chain(add.s(4, 5), multiply.s(10))()
print(chain_result.get())  # Output: (4 + 5) * 10 = 90
```
    
- **Group**  - дозволяє виконувати кілька завдань паралельно, після чого результати збираються разом. Корисно для незалежних обчислень.
    
```python
from celery import group

group_result = group(add.s(2, 2), add.s(4, 4), add.s(6, 6))()
print(group_result.get())  # Output: [4, 8, 12]
```
    
- **Chord**  - комбінація групи та завершального завдання. Спочатку виконується група завдань паралельно, а після їх завершення викликається фінальне завдання, яке отримує результати всієї групи.
    
```python
from celery import chord

def final_task(results):
	return sum(results)

chord_result = chord(group(add.s(2, 2), add.s(4, 4), add.s(6, 6)))(final_task.s())
print(chord_result.get())  # Output: 4 + 8 + 12 = 24
```
    
- **Map і Starmap**  - використовуються для виконання функцій з ітеративними аргументами, подібно до функції `map`.
    
```python
from celery import group

mapped_result = group(add.starmap([(2, 2), (4, 4), (6, 6)]))()
print(mapped_result.get())  # Output: [4, 8, 12]
```
    
- **Chunks**  - використовується для розбиття великого набору даних на менші частини та паралельної обробки кожної частини.
    
```python
from celery import chunks

chunked_result = add.chunks([(i, i) for i in range(10)], 3)()
print(chunked_result.get())
```
    
- **Retry**  - завдання можуть автоматично повторюватись у разі помилки, що корисно для роботи з ненадійними зовнішніми сервісами.
    
```python
@app.task(bind=True, max_retries=3)
def fragile_task(self):
	try:
		# Perform some operation
		pass
	except Exception as e:
		self.retry(countdown=5, exc=e)
```
    
