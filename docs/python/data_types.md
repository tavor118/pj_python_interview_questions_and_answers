## Data Types

### Які типи даних є в Python

Примітивні типи даних
- Цілі числа (int)
	- Python не має обмеження по значенню int
	- Числа від -5 до 256 вже завантаженні при ініціалізації (якщо створити ціле число в цьому діапазоні, то воно будете посилатися на той самий об'єкт у пам'яті)

```python
a = 1
b = 1
a is b  # True
a = 300
b = 300
a is b  # False
a == b  # True
```

- Дійсні числа (float) - числа з плаваючою комою
- Комплексні числа (complex)
- Рядки (str)
- Булеві значення (bool) - True, False
- None - тип, який вказує на відсутність значення.

Колекції (містять в собі інші об'єкти)
- Списки (list)
- Кортежі (tuple)
- Словники (dict)
- Множини (set)
- Фрозенсет (frozenset) - аналог множини, але не змінюється після створення

Також до примітивних типів ще відносять:
- Байти (bytes) - незмінний (immutable) тип даних, який використовується для представлення послідовності байтів - `b'hello'`
- Байтові масиви (bytearray) - подібно до байтів, але можуть бути змінюваними -`bytearray(b'hello')`

Також типи даних діляться на mutable and immutable
- Mutable - list, dict, set
- Immutable - int, string, tuple, frozenset, boolean, NoneType


### Яка різниця між змінними і незмінними типами даних в Python?

В Python є два основні типи даних за їхньою здатністю до зміни: змінні (mutable) та незмінні (immutable).

**Незмінні типи**  - це типи даних, значення яких не можна змінити після створення. Якщо змінювати значення змінної з таким типом, Python створить новий об'єкт у пам'яті, а не змінить існуючий. Зберігаються в пам'яті як окремі об'єкти. Якщо створюється нове значення, Python створює новий об'єкт, і змінна вказує на нього. Для малих та часто використовуваних об'єктів, таких як малі цілі числа чи короткі рядки, Python може використовувати "пул об'єктів", щоб зменшити кількість створюваних об'єктів.

**Змінні типи** можна змінювати без створення нового об'єкта. Це означає, що після зміни вмісту об'єкта його адреса в пам'яті не змінюється. Python зберігає посилання на об'єкт у пам'яті, і при зміні значення об'єкта його адреса в пам'яті залишається тією самою. Це означає, що якщо змінюється список або словник, зміни відбуваються на місці.

```python
x = 10  # Immutable type
print(id(x))  # Shows memory address - 4392920520

x = 20  # Creates a new object
print(id(x))  # Address will change - 4392920840

y = [1, 2, 3]  # Mutable type
print(id(y))  # Memory address - 4418755008

y.append(4)  # Modifies the existing object
print(id(y))  # Address remains the same - 4418755008
```

У Python, всі об'єкти зберігаються в купі (heap). Це справедливо і для змінних, і для незмінних типів даних. Купа забезпечує динамічне виділення пам'яті, що дозволяє створювати нові об'єкти за потреби.

Namespace, або простір імен, створюється у стеку. Коли викликається функцію або імпортується модуль, стек використовується для зберігання контексту виконання, включаючи локальні змінні і простори імен. Об'єкти, на які посилається цей простір імен, залишаються у купі.

Тобто коли імпортується модуль, інтерпретатор Python зберігає змінні та об'єкти модуля в купі, а простір імен модуля використовується для доступу до цих змінних та об'єктів у програмі - купа зберігає дані, а стек - виклики функцій і контексти.


### Який паттерн реалізовують `None`, `False`, `True` в Python?

В Python `None`, `False`, та `True` є об'єктами, які представляють відповідно відсутність значення, логічне значення "неправда" та логічне значення "істина". 
Вони є єдиними об'єктами своїх класів і реалізовані за допомогою паттерну Singleton, який гарантує, що клас має лише один екземпляр і забезпечує глобальний доступ до нього. Це означає, що в будь-якому місці програми, якщо ми створюємо змінну зі значенням `None`, `False` або `True`, то ми завжди будемо посилатись на той самий об'єкт в пам'яті. Це дозволяє зменшити використання пам'яті та зробити програму більш ефективною.

`None` - це об'єкт типу `NoneType` і є єдиним представником цього типу. 

```python
>>> type(None).__mro__
(<class 'NoneType'>, <class 'object'>)
```

### Що таке перетворення типів у Python?

Перетворення типів у Python - це процес зміни типу даних одного об'єкта на інший тип.
- `str()` - використовується для перетворення цілого числа у рядок
- `int()` - перетворює будь-який тип даних на цілочисельний тип
- `float()` - перетворює будь-який тип даних на дробовий тип
- `ord()` - перетворює символи на цілі числа
- `hex()` - перетворює цілі числа в шістнадцятковий формат
- `oct()` - перетворює цілі числа в вісімковий формат
- `tuple(), set(), list() `- конвертувати у відповідну колекцію
- `dict() `- ця функція використовується для перетворення кортежу виду `((key, value), ...)` у словник
- `bool()` - для перетворення іншого об'єкта на тип `bool`


### Bolean

При роботі з умовними виразами (наприклад, `if` і `while`) та в логічних операціях (наприклад, `and`, `or`, `not`) об'єкти приймають наступні значення:
- `False`
	- пустий список: `[]`
	- пустий кортеж: `()`
	- пустий словарь: `{}`
	- пуста множина: `set()`
	- пустий рядок `""`
	- нуль - `0`
	- `None`
- `True` - любий об'єкт, число відмінне від 0, люба непуста послідовність або колекція
- `and` повертає останній істинний або перший неістинний
- `or` повертає перший істинний або останній не істинний
- `not` - повертає boolean

```python
list1 = [1, 2, 3]
list2 = []
result = list1 and list2  # []
result = list2 and list1  # []
list3 = [4, 5, 6]
result = list1 and list3  # [4, 5, 6]

tuple1 = (10, 20, 30)
tuple2 = ()
result = tuple1 or tuple2  # (10, 20, 30)
result = tuple2 or tuple1  # (10, 20, 30)
result = list1 or tuple1  # [1, 2, 3]

result = not list1  # False
result = not tuple2  # True
```


### Decimal

*Summary*
Модуль `decimal` у Python використовується для виконання точних арифметичних операцій із числами з плаваючою комою. Це особливо корисно, коли потрібно уникнути похибок, пов’язаних зі стандартним типом `float`. Модуль дозволяє працювати з фінансовими розрахунками, точними науковими обчисленнями та іншими задачами, де важлива висока точність.

Основні моменти про `decimal`
- Клас `Decimal` забезпечує точне представлення чисел. Наприклад, значення `0.1` в `float` зберігається з похибкою, тоді як `Decimal('0.1')` буде точним.
- Значення в `Decimal` повинні передаватися як рядки або цілі числа для уникнення втрати точності, що може виникати під час використання `float`.
- Є підтримка спеціальних значень, таких як нескінченність або Not a Number (NaN).

```python
from decimal import Decimal, getcontext

getcontext().prec = 6  # Set global precision: 6 digits
a = Decimal('0.1')
b = Decimal('0.2')
c = a + b
print(c)  # Output: 0.3 (precise value)
```

Модуль дозволяє налаштовувати поведінку операцій, включаючи методи округлення:

```python
from decimal import Decimal, ROUND_HALF_UP

value = Decimal('1.2345')
rounded_value = value.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)  # Rounding example
print(rounded_value)  # Output: 1.23
```

Порівняння `Decimal` і `float`:

```python
print(0.1 + 0.2)  # Output: 0.30000000000000004 (imprecision)  # Float
print(Decimal('0.1') + Decimal('0.2'))  # Output: 0.3 (precise)  # Decimal
```


### Яка різниця між \==, `is` та `isinstance()`

Оператор == порівнює значення.  Використовується в порівнянні рядків, чисел чи інших значень, коли важливе порівняння саме даних.

Оператор `is` is перевіряє `id`, чи це той самий обєкт. `id` - унікальний ідентифікатор об'єкту. Ідентификатор присвоюється об'єкту під час його створення. Ідентифікатор є адресою пам'яті об'єкта і буде відрізнятися під час кожного запуску програми..

PEP 8 вказує на те, що оператор `is` слід використовувати для порівняння з `None`, `True` та `False`, оскільки ці об'єкти-синглетони завжди мають один єдиний екземпляр в пам'яті.

`isinstance()` є функцією, яка перевіряє, чи належить об'єкт до певного класу або типу даних.


### Анотації типів (Type Hints). PEP 484

**Підказки типів (Type Hints),  Аннотації типів (Type Annotations)** — це спосіб вказати очікувані типи аргументів функцій, значень змінних і результатів, що повертаються. Це допомагає зробити код більш зрозумілим, полегшує підтримку і знижує ризик помилок.

PEP 484 (Python Enhancement Proposal 484) - вводить підтримку підказок типів у Python. Він стандартизує синтаксис та семантику аннотацій типів і надає рекомендації щодо їх використання в Python-проектах.

- Анотації додаються до сигнатури функцій або змінних, але вони не впливають на виконання коду. Python ігнорує їх під час виконання, залишаючи це на розсуд розробника чи сторонніх інструментів, таких як статичні аналізатори (наприклад, `mypy`).
- `mypy` - інструмент для перевірки типів (Type Checking). `mypy` аналізує код і перевіряє, чи відповідають вказані типи фактичним типам даних, що передаються та повертаються функціями. 
- Основне призначення анотацій типів — документування і поліпшення якості коду. Вони дозволяють чітко вказати, з якими типами даних працює функція, що значно спрощує розуміння логіки програми.
- Анотації виконуються під час компіляції (у момент інтерпретації файлу Python), але лише у вигляді метаданих. Їх можна отримати через атрибут `__annotations__`.
- Хоча анотації не виконуються під час виконання коду, їх можна використовувати в спеціалізованих сценаріях, наприклад, для генерації API або перевірки типів у реальному часі.

```python
def add_numbers(x: int, y: int) -> int:    
    return x + y  # Function takes two integers and returns an integer
```

Анотації також можна використовувати зі змінними

```python
age: int = 30  # Variable is expected to be of type int
name: str = "Alice"
```

Для складних структур, таких як списки чи словники, в старіших версіях Python використовують модуль `typing`

```python
from typing import List, Dict

numbers: List[int] = [1, 2, 3]  # List of integers
user_data: Dict[str, int] = {"age": 30, "score": 100}  # Dictionary with string keys and integer values
```



### Для чого використовуються файли з розширенням `pyi` ?

Файли з розширенням `.pyi` (python Interface) файли або stub-файли, використовуються для надання анотацій типів для Python модулів. Вони допомагають у статичній перевірці типів і поліпшенні інтеграції з інструментами статичного аналізу, такими як `mypy`. Вони дозволяють визначити типи для модулів, без необхідності змінювати їхній вихідний код.

Основні призначення `.pyi` файлів:
- Додавання типів до існуючих модулів. Якщо є модуль без анотацій типів (наприклад, написаний на Python або навіть C), `.pyi` файли дозволяють описати інтерфейс цього модуля для інструментів статичного аналізу, таких як `mypy`.
- Розділення типізації та реалізації. У деяких проєктах зручно тримати анотації типів окремо від основного коду, щоб не ускладнювати його.
- Автоматична генерація документації. Інструменти для документації можуть використовувати `.pyi` файли для створення зрозумілих API-документів.
- Статичний аналіз коду. Інструменти, такі як `mypy`, використовують `.pyi` файли для перевірки правильності типів у вашій програмі.

`.pyi` файли виглядають як звичайні Python-файли, але замість реалізації функцій вони містять лише їхні сигнатури. Вони підтримують всі типи анотацій, доступні через модуль `typing`.

Приклад `.pyi` файлу для модуля `math`
- Функції визначені без реалізації (з використанням `...`).
- Використовуються анотації типів для параметрів та значення, що повертається.

*math.pyi*

```python
from typing import overload

def sqrt(x: float) -> float: ...
def factorial(x: int) -> int: ...

@overload
def pow(x: int, y: int) -> int: ...
@overload
def pow(x: float, y: float) -> float: ...
```

