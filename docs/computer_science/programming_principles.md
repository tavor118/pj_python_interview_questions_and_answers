## Принципи програмування

### KISS

Принцип **Keep It Stupid Simple** (Зберігайте це простим, Притримуйтесь простоти) вимагає, щоб код був максимально простим. Чим простіший код, тим легше розібратися в ньому як автору, так і іншим людям, що займаються його підтримкою. Під простотою головним чином розуміється відмова від використання хитрих прийомів та зайвого ускладнення.

Прикладом порушення цього принципу може бути написання окремої функції тільки для виконання операції додавання або використання побітового оператора (зсув вправо >> 1) для ділення цілих чисел на 2. Останнє, безумовно, ефективніше, ніж звичайне (/2), але при цьому дуже знижується зрозумілість коду. Використовуючи такий підхід, реалізовується "розумний кодинг" (clever coding) та надмірна оптимізаціґ (over-optimization). І те, і інше у довгостроковій перспективі не є дуже корисним для підтримки коду.


### DRY

**Don’t Repeat Yourself (Не повторюйся)** - принцип, який полягає в тому, що повторювану дію в коді слід виносити в окрему функцію для можливості багаторазового використання. Треба намагатись уникати однакових фрагментів коду, оскільки це призводить до розсинхронізації. Такий код важко підтримувати в актуальному стані. Також це збільшує кількість коду та кількість необхідних тестів. 

Загальне емпіричне правило в інженерії програмного забезпечення, стверджує, що компонент слід випробувати принаймні три рази, перш ніж розглядати створення багаторазового компонента. Також створити багаторазові компоненти втричі важче, ніж створити прості.


### YAGNI

**You Aren’t Gonna Need It** (Тобі це не знадобиться) - принцип, що стверджує, що небажано залишати в програмі "точки розширення" (місця, призначені лише для того, щоб дозволити вам у майбутньому легко додати новий функціонал). Звичайно, це не стосується випадків, коли йдеться про вже запланований функціонал. Такі точки розширення вносять зайву складність та збільшують розмір кодової бази.


### SLAP

Принцип **Single Level of Abstraction Principle (Принцип єдиного рівня абстракцій)** означає, що функції повинні мати єдиний рівень абстракції. Наприклад, функція, яка читає вхідні дані, не повинна також обробляти отримані дані. Для цього вона повинна задіяти окрему функцію, яка знаходиться на іншому, більш низькому рівні абстракції. Чим загальнішою є функція та чим більше інших функцій вона використовує, тим вище вона розташована в абстракційній ієрархії.


### GRASP

**GRASP (General Responsibility Assignment Software Patterns)** — це набір принципів проєктування, які допомагають розподіляти відповідальності між класами та об'єктами у програмному забезпеченні. Вони спрямовані на створення системи, яка легко підтримується, розширюється та розуміється.

За своєю суттю, цей набір патернів більш абстрактний, ніж загально відомий каталог шаблонів від «Банди чотирьох» (GOF-шаблони), та не мають вираженої структури, чіткої області застосування і конкретної розв'язуваної проблеми, а лише являють собою узагальнені підходи / рекомендації / принципи, використовувані при проектуванні дизайну системи. До складу шаблонів GRASP входить 9 шаблонів. 

Принципи GRASP можна поділити на групи

* Група 1: Фундаментальні принципи моделі - Cohesion, Coupling, Information Expert, Creator - 
  - Ці патерни задають саму суть: структуру, пов'язаність та здоровий глузд проектування. Вони застосовні як до окремих класів, так і до модулів, і до сервісів - формуючи основу, на яку спираються інші архітектурні рішення.
* Група 2: Інженерні надбудови - Pure Fabrication, Indirection, Controller
  - Ця група шаблонів не прагне моделювати предметний світ. Навпаки - вона пропонує синтетичні, штучні конструкції, які не потрібні бізнесу, а потрібні архітектурі. Вони допомагають дотриматися принципів, підвищити гнучкість і спростити супровід.
* Група 3: Polymorphism та Protected Variations — про гнучкість, стійкість та захист від змін

Основні принципи GRASP

* **Low Coupling**: низька пов'язаність між компонентами. Зменшує залежність між класами, що спрощує підтримку та тестування. Чим менше залежностей між модулями, тим:
  - вище модульність
  - менше каскадних змін
  - легше тестувати та замінювати частини системи
* **High Cohesion**: висока зв'язаність функціональності усередині компонента. Заохочує концентрацію відповідальності в межах одного класу, що робить його більш зрозумілим та функціональним. Коли поведінка логічно об'єднана та сфокусована, система стає:
  - простіша у підтримці
  - легша для розуміння
  - надійніша при змінах
* **Information Expert**: відповідальність повинна бути покладена на той клас, який має найбільше необхідної інформації для виконання завдання. Це дозволяє:
  - підвищити Cohesion
  - знизити дублювання
  - позбутися анемічних моделей і перейти до rich-домену, де дані та поведінка нероздільні.
* **Creator**: визначає, який клас повинен створювати інші об'єкти, базуючись на наявних зв'язках між класами. Той, хто ближчий до об'єкта, і повинен його створювати.
  - В якомусь сенсі можна спрощено сказати, що Creator — це окремий випадок Information Expert, який застосовується саме до створення об'єктів. Він слідує тій же логіці: "у кого є дані — той і діє", але сфокусований на одному конкретному аспекті — моменті створення.
* **Pure Fabrication**: введення штучного класу для зниження зв'язності або підвищення узгодженості. Класичний приклад – репозиторій. Це не бізнес-сутність, а прошарок між логікою та базою даних. Тобто Pure Fabrication пропонує створювати штучні абстракції, які:
  - не відображають предметну область
  - але потрібні для архітектурної чистоти
  - і дотримуються принципів Low Coupling та High Cohesion
* **Indirection**: керуй залежностями через прошарки. Використання посередника для зменшення залежності між компонентами. 
  - По суті, Indirection - це ідея, що лежить в основі багатьох архітектурних рішень.
    - У DDD може бути сервіс, координуючий бізнес-логіку.
    - У гексагональній архітектурі - адаптер, який отримує дані ззовні.
    - У UI - контролер, що приймає запит користувача і передає далі.
  - Indirection - це не просто "прокинути виклик". Це може бути і збагачення даних, і трансформація інтерфейсу, і додаткова логіка залежно від потреб системи. Тому такі патерни, як Adapter, Decorator, Proxy, Facade можна розглядати як приватні реалізації ідеї Indirection
* **Controller**: встановлює, який клас відповідає за обробку запитів і управління потоками в системі. Controller відповідає на запитання: Хто першим отримує зовнішні події та координує поведінку системи?
  - Важливо розуміти: Controller це не конкретний шар і не конкретний фреймворк-специфічний компонент. Це архітектурна роль, завдання якої грамотно розрулити вхід і передати його туди, де відбуватиметься справжня дія.
  - Controller може жити на різних шарах:
    - UI-контролер - приймає вхід користувача, парсить, валідує
    - Use-case-контролер - координує сценарій, викликає необхідні сервіси
  - Один може викликати інший, створюючи каскад компонентів, що управляють. Це нормально — особливо в системах із виділеним шаром Application, як у DDD чи гексагональній архітектурі.
  - Controller – точка входу в систему. Саме тут можна:
    - обернути виконання на транзакцію
    - перевірити права доступу
    - залогувати сценарій або метрики
    - адаптувати вхідні дані до внутрішнього API
* **Polymorphism**: одна з базових концепцій ООП - це здатність функції працювати з об'єктами різних типів. Забезпечує можливість використання спільного інтерфейсу для різних типів об'єктів, дозволяючи динамічне виконання методів.
  - Паттерн Polymorphism із GRASP відповідає на запитання: Як проектувати поведінку, яка має різнитися залежно від типу об'єкта? Рішення: Винеси поведінку в абстракцію – і нехай кожен тип реалізує свою.
  - Переваги:
    - прибирається умовна логіка (if, switch)
    - код стає розширюваним без змін у старому
    - досягається принцип OCP - open for extension, closed for modification
* **Protected Variations**: захищає систему від змін у компонентах, використовуючи абстракції, захистити компоненти системи від змін інших частин. 
  - Суть
    - Ізолювати ділянки, що потенційно змінюються, стабільними абстракціями.
    - Передбачити варіативність заздалегідь як архітектурну страховку.
  - Приклади реалізацій
    - DDD - Репозиторій захищає доменну модель від змін до БД
    - Hexagonal Architecture - Адаптери захищають ядро від API, UI, брокерів
    - Чиста архітектура - Зовнішні шари залежать від внутрішніх через інтерфейси

Cohesion та Coupling працюють не лише на рівні класів, а й на рівні архітектурних кордонів. Наприклад, у DDD Bounded Context - це свого роду макро-Cohesion: всередині контексту - єдина, зв'язана модель, зовні - слабко пов'язані інтерфейси між контекстами.

Приклад реалізації Information Expert

```python
class Order:
    def __init__(self, items):
        self.items = items

    def calculate_total_price(self): # Order is the Information Expert as it knows about its items        
        return sum(item.price for item in self.items)

class Item:
    def __init__(self, name, price):
        self.name = name
        self.price = price

items = [Item("Apple", 1.5), Item("Banana", 0.5)]
order = Order(items)
print(order.calculate_total_price())  # Output: 2.0
```

*Links*

- https://habr.com/ru/articles/900140/


### TDD Test driven development

**TDD (Test driven development)** – це методологія розробки програмного забезпечення, яка ґрунтується на написанні тестів перед написанням коду. Це дозволяє  писати якісніший код, який легше підтримувати та змінювати.

Коли програмісти використовують TDD, вони пишуть тести, які перевіряють, чи код працює правильно. Потім вони пишуть код, який проходить випробування. Цей процес повторюється доти, доки всі тести не проходять.

Переваги TDD полягають у тому, що він дозволяє програмістам швидко виявляти та виправляти помилки, робить код більш надійним та зменшує кількість помилок у продукті. Крім того, TDD допомагає програмістам краще розуміти вимоги до коду та покращує комунікацію в команді розробки.

Приклад використання TDD може бути наступним: програміст пише тест, який перевіряє, що функція, що він збирається написати, повертає очікуваний результат. Потім пише код, який проходить тест. Якщо тест не проходить, він виправляє код, доки тест не буде пройдено. Цей процес повторюється кожної функції, що він пише. В результаті програміст отримує якісніший код, який легше підтримувати та змінювати.

TDD особливо корисний при написанні додаткового функціоналу до вже існуючого коду, або при виправленні багів, оскільки ми спочатку пишемо тести, які падають, а потім відповідний код, який це виправляє.


