## Індексація

### Що таке індекси? Навіщо вони потрібні? Як вони працюють?

*Summary*
>  **Індекси** - це структури даних у базах даних, які допомагають прискорити пошук і фільтрацію даних. Вони створюються для певних полів таблиць і дозволяють базі даних здійснювати швидший доступ до конкретних рядків.

Індекси потрібні для покращення продуктивності запитів, особливо коли потрібен пошук або фільтрація даних за певними полями. Вони допомагають зменшити кількість рядків, які база даних повинна перевірити, щоб знайти відповідні результати.

Індекси працюють шляхом створення додаткової структури даних, яка має відображення на значення поля та посилання на відповідний рядок у таблиці. При пошуку даних за індексованим полем база даних спочатку переходить до відповідного запису в індексі, а потім знаходить відповідний рядок у таблиці.

Індекси не є безкоштовними. Вони займають додатковий обсяг місця на диску і впливають на швидкість вставки, оновлення і видалення даних. Тому їх слід створювати обдумано, зважаючи на типи запитів, які будуть використовуватися в проекті.

Індекси підвищують продуктивність запитів на вибірку даних, але одночасно можуть збільшити час виконання операцій вставки, оновлення та видалення, адже база даних також повинна оновити індекс.

У PostgreSQL індекси реалізовані різними способами. Наприклад, B-дерева є одним з найпоширеніших типів індексів. Вони дозволяють швидкий пошук значень і забезпечують ефективну підтримку різних операцій порівняння, таких як менше, більше, дорівнює тощо.

*Links*

- https://www.youtube.com/watch?v=ju9F8OvnL4E

### Які популярні типи індексів існують?

- **B-дерево (B-Tree) індекс:** Це один з найпоширеніших типів індексів. B-дерева використовуються для оптимізації пошуку даних у впорядкованих полях, таких як числа та рядки. Вони дозволяють виконувати операції порівняння (менше, більше, дорівнює) дуже швидко.
- **Хеш-індекс:** Хеш-індекси використовують хеш-функції для швидкого пошуку даних. Вони підходять для запитів з точним збігом значень. Однак, вони не так ефективні для діапазонних запитів або запитів, які використовують оператори порівняння.
- **GIN (Generalized Inverted Index) індекс:** Цей тип індексу використовується для повнотекстового пошуку та інших варіантів пошуку, які вимагають обробки великої кількості слів або термінів.
- **GiST (Generalized Search Tree) індекс:** GiST індекси призначені для роботи зі складними даними, такими як географічні дані, діапазони дат та інші. Це збалансоване дерево пошуку, точно так само, як і розглянуте раніше B-дерево. Але B-дерево застосовне лише до тих типів даних, для яких має сенс операція порівняння та є можливість упорядкування. Проте PostgreSQL дозволяє зберігати і такі дані, для яких операція упорядкування не має сенсу, наприклад, геодані та геометричні об'єкти.
- **SP-GiST (Space-Partitioned Generalized Search Tree) індекс:** Цей тип індексу використовується для роздільних даних, які можна розбити на області. Наприклад, для географічних даних це можуть бути координати на карті. SP-GiST схожий із GiST, але він дозволяє створювати незбалансовані дерева. Такі дерева можуть бути корисними при розбитті множини на  об'єкти які не перетинаються. Літери SP означають space partitioning.

*Links*

- https://tproger.ru/articles/indeksy-v-postgresql/

### UUID

**UUID (Universally Unique Identifier)** — це унікальний ідентифікатор, який широко використовується для створення унікальних значень, незалежно від середовища, де вони генеруються. У Python для роботи з UUID використовується стандартний модуль `uuid`.

UUID гарантує глобальну унікальність без потреби централізованого генератора. Тобто UUID можна генерувати на різних машинах без ризику конфліктів. Це особливо корисно в розподілених системах, де різні вузли мають створювати унікальні ID без координації. З `int` треба дбати про автоінкремент і потенційні дублікати в розподілених системах.

Є кілька версій UUID, які підтримує Python

- `uuid1()` — базується на timestamp + MAC-адресі. Вразливий до витоку інформації про пристрій (можна деанонімізувати пристрій).
- `uuid3()` — генерується з імені + namespace, використовуючи хеш MD5.
- `uuid4()` — базується на випадкових числах, що забезпечує високий рівень унікальності. Повністю випадковий (найчастіше використовується).
- `uuid5()` — як uuid3, але з SHA-1 замість MD5.

У базах даних часто використовують UUID як primary key для моделей, що дає додаткову безпеку (складно передбачити значення ID).
UUID зручно використовувати для API: вони не інкрементальні, тому менш вразливі до "ID guessing".

При збереженні UUID в базі даних зазвичай використовують тип `UUIDField` у Django, який мапиться на `uuid` тип у PostgreSQL (або як `char(32)` у SQLite).

UUID складається із 128-бітного числа, представленого у вигляді 32-символьного рядка шістнадцяткових цифр, розділеного дефісами. Наприклад: `550e8400-e29b-41d4-a716-446655440000`.
У UUID4 ймовірність колізії настільки мала, що її практично можна ігнорувати.

Мінуси UUID

- Розмір: UUID займає більше місця (16 байт проти 4 байт для `int`). Може призводити до збільшення розміру індексів (і відповідно БД) та сповільнення операцій вставки й пошуку.
- Продуктивність:  У базах даних, де використовуються кластеризовані індекси, додавання UUID (особливо версії 4) може бути менш ефективним, оскільки ці ідентифікатори вставляються у випадковому порядку. У деяких реляційних СУБД (наприклад, SQL Server, MySQL) первинний ключ за замовчуванням є кластеризованим індексом. Ті самі проблеми відносяться що BTree. Це може спричиняти фрагментацію індексу та впливати на продуктивність. Через хаотичність UUID4 PostgreSQL вимушений постійно відкривати різні сторінки індексу, а не одну й ту ж. Це веде до менш ефективного кешу та зростання I/O. Тобто через більший розмір і відсутність порядку UUID індекси гірше кешуються, що може сповільнити пошук, сортування та джоїни. Числові ключі швидші для порівняння, пошуку та індексації.
- Зручність: UUID важче читати й використовувати при налагодженні або ручній роботі з базою даних у порівнянні з простими числовими ідентифікаторами. Для людини зручніше працювати з простими числами, ніж з довгими UUID.

Частково проблеми uuid4 вирішуються в uuid7. UUID7 — це той самий знайомий формат UUID, але оптимізований для продуктивності та порядковості. Він покликана вирішити ключову проблему `uuid4` — хаотичність і слабку індексацію.

Переваги в порівнянні з `uuid4`

- Порядковість (sortable)  - UUID7 включає timestamp в перших байтах, що робить його монотонним — нові значення автоматично йдуть після старих. Це ідеально підходить для кластеризованих індексів. На відміну від `uuid4`, UUID7 можна використовувати для `ORDER BY`, `LIMIT`, `pagination` без додаткового поля типу `created_at`.
- Менше фрагментації - Порядкові UUID краще вписуються в кластеризований індекс — дані вставляються "в кінець", а не "в середину", як це буває з `uuid4`. Це зменшує фрагментацію сторінок у базі й пришвидшує вставку.
- Все ще унікальний - UUID7 використовує мікс `timestamp` + `randomness`, що зберігає глобальну унікальність і забезпечує надійність у розподілених системах.

Підсумок

- Якщо проект критично залежить від продуктивності, і UUID не є обов’язковими — краще використовувати `int`.
- Якщо важлива безпека, масштабованість і незалежність — UUID має сенс, особливо для публічних ресурсів або мікросервісів.

### В яких випадках використовується `CREATE INDEX CONCURRENTLY`

Опція `CONCURRENTLY` при створенні індексів використовується для того, щоб дозволити доступ до таблиці під час процесу створення індексу. Це допомагає створювати індекси для великих таблиць, коли потрібно забезпечити доступ 24/7, оскільки звичайне створення індексу викликає блокування, яке може впливати на доступність системи та продуктивність. Ось деякі випадки, коли використання `CREATE INDEX CONCURRENTLY` є доцільним:

Використання `CONCURRENTLY` може зайняти більше часу порівняно зі звичайним створенням індексу, але це дозволяє уникнути блокування таблиці.

```sql
CREATE INDEX CONCURRENTLY index_name ON table_name (column_name);
```

### Що таке seq-scan? Коли він виконується, навіть якщо є індекси?

**Seq-scan (sequential scan)** — це метод доступу до даних у таблиці, який використовується в системах управління базами даних (наприклад, PostgreSQL). Під час seq-scan сервер бази даних читає всі рядки таблиці послідовно, незалежно від того, чи є індекси для цієї таблиці.

В посгресі вибір між "використовувати" і "не використовувати" індекс проводиться планувальником і іноді він може вирішити, що робити IndexScan безглуздо, наприклад, якщо таблиця дуже маленька (але не тільки в цьому випадку).

Коли виконується seq-scan, навіть якщо є індекси

- **Запит сканує значну частину таблиці**  - якщо запит повертає великий відсоток рядків таблиці, сервер може вирішити, що використання seq-scan швидше, ніж доступ через індекси. Індекси підходять для вузьких вибірок, але якщо потрібно зчитати майже всі дані, seq-scan стає вигіднішим.
- **Індекси не охоплюють умову фільтрації**  - якщо у запиті є умова фільтрації, яка не відповідає існуючому індексу (наприклад, фільтрація за полем, яке не індексоване), база даних змушена виконувати seq-scan.
- **Маленький розмір таблиці**  - для дуже маленьких таблиць використання seq-scan може бути швидшим, ніж доступ через індекси, оскільки читання даних напряму із таблиці уникає додаткових накладних витрат на пошук у індексі.
- **Інкрементальні оновлення таблиці**  - якщо таблиця має багато нещодавно доданих/змінених рядків (через механізм MVCC у PostgreSQL), сервер може обрати seq-scan, щоб уникнути накладних витрат на підтримку актуальності індексів. Регулярне виконання `ANALYZE` та `VACUUM` допомагає оптимізатору краще оцінювати розмір таблиці та вибирати правильний план.
- **Складні функції або вирази**  - якщо запит використовує функції або складні обчислення у `WHERE`, і індекс не покриває ці обчислення (наприклад, `LOWER(column) = 'value'` без створеного індексу для `LOWER(column)`), індекси не будуть використані.
- **Налаштування параметрів оптимізатора**  - у PostgreSQL параметри `random_page_cost` і `seq_page_cost` впливають на вибір оптимізатора. Якщо `seq_page_cost` низький (або рівний за замовчуванням), оптимізатор може віддавати перевагу seq-scan.

